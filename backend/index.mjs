import express from 'express';
import cors from 'cors';
import axios from 'axios';
import dotenv from 'dotenv';
import { create } from 'ipfs-http-client';
import crypto from 'crypto';

dotenv.config({ path: '../.env' });

const ipfsClient = create({ host: 'ipfs.infura.io', port: '5001', protocol: 'https' });
const imageMap = new Map();

const app = express();

app.use(cors());
app.use(express.json());

const API_KEY = process.env.OPENAI_API_KEY;

app.post('/generate-images', async (req, res) => {
  const { setting, verb } = req.body;
  console.log(`Photograph of a ${setting} ${verb}`);

  // Construct the prompt for DALL-E
  const prompt = `Create an image of a ${setting} scene with a ${verb} action`;

  try {
    const response = await axios.post(
      'https://api.openai.com/v1/images/generations',
      {
        model: 'image-alpha-001',
        size: '512x512',
        prompt,
        n: 1, // Generate one image
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${API_KEY}`,
        },
      }
    );

    // Map the image ID to the URL
    const images = response.data.data.map((image) => {
      const id = crypto.createHash('sha256').update(image.url).digest('hex');
      imageMap.set(id, image.url);
      return { id, url: image.url };
    });

    console.log('Generated images:', images);

    res.json(images);
  } catch (error) {
    console.error('Error generating images:', error);
  }
});

app.post('/api/mint', async (req, res) => {
  const { imageId, account } = req.body;

  const imageUrl = imageMap.get(imageId);
  if (!imageUrl) {
    return res.status(400).json({ error: 'Invalid image ID' });
  }

  try {
    // Save image to IPFS
    const imageResponse = await axios.get(imageUrl, { responseType: 'arraybuffer' });
    const imageBuffer = Buffer.from(imageResponse.data);
    const imageResult = await ipfsClient.add(imageBuffer);

    const imageCID = imageResult.path;
    const ipfsImageUrl = `https://ipfs.io/ipfs/${imageCID}`;

    // Create the metadata JSON object
    const metadata = {
      name: 'AI Generated Image',
      description: 'An image generated by AI',
      image: ipfsImageUrl,
    };

    // Save metadata to IPFS
    const metadataBuffer = Buffer.from(JSON.stringify(metadata));
    const metadataResult = await ipfsClient.add(metadataBuffer);

    const metadataCID = metadataResult.path;
    const ipfsMetadataUrl = `https://ipfs.io/ipfs/${metadataCID}`;

    // Mint the NFT using the IPFS metadata URL
    const tokenId = await contractInstance.methods.mint(account, ipfsMetadataUrl).send({ from: account });

    res.json({
      tokenId: tokenId, // The actual tokenId from the mint function
      contractAddress: '0x5FbDB2315678afecb367f032d93F642f64180aa3', // Replace with the actual contractAddress
    });
  } catch (error) {
    res.status(500).json({ error: 'Error minting NFT' });
  }
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

async function initializeWeb3Client() {
  if (typeof window.ethereum !== 'undefined') {
    const web3 = new Web3(window.ethereum);
    try {
      // Request account access if needed
      await window.ethereum.enable();
      // Get the user's account
      const accounts = await web3.eth.getAccounts();
      const account = accounts[0];

      return { web3, account };
    } catch (error) {
      console.error('Error enabling Ethereum or getting accounts:', error);
    }
  } else {
    console.error('Non-Ethereum browser detected. You should consider trying MetaMask!');
  }
}

export { initializeWeb3Client };