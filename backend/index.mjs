import express from 'express';
import cors from 'cors';
import axios from 'axios';
import dotenv from 'dotenv';
import { create } from 'ipfs-http-client';
import crypto from 'crypto';
import Web3 from 'web3';
import fs from 'fs';
import { promisify } from 'util';

const readFile = promisify(fs.readFile);

// Load the contract ABI
async function loadABI(file) {
  const data = await readFile(file, 'utf8');
  return JSON.parse(data);
}

// Load the .env file
dotenv.config({ path: '../.env' });

// Create an IPFS client
const ipfsClient = create({
  host: 'ipfs.infura.io',
  port: '5001',
  protocol: 'https',
  headers: {
    authorization: `Basic ${Buffer.from(`${process.env.INFURA_PROJECT_ID}:${process.env.INFURA_PROJECT_SECRET}`).toString('base64')}`,
  },
});

// Used to map image IDs to URLs
const imageMap = new Map();

const app = express();

app.use(cors());
app.use(express.json());

const API_KEY = process.env.OPENAI_API_KEY; // Set this in your .env file
const CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS; // Set this in your .env file
const web3 = new Web3(process.env.ALCHEMY_RPC_URL); // Set this in your .env file

app.post('/generate-images', async (req, res) => {
  const { description } = req.body;

  const prompt = `art gallery photograph of a gleaming highly detailed shiny solid gold ${description} amulet`;
  console.log(prompt)

  try {
    const response = await axios.post(
      'https://api.openai.com/v1/images/generations',
      {
        model: 'image-alpha-001',
        size: '512x512',
        prompt,
        n: 3,
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${API_KEY}`,
        },
      }
    );

    const images = response.data.data.map((image) => {
      const id = crypto.createHash('sha256').update(image.url).digest('hex');
      imageMap.set(id, image.url);
      return { id, url: image.url };
    });

    console.log('Generated images:', images);

    res.json(images);
  } catch (error) {
    console.error('Error generating images:', error);
  }
});

app.post('/mint', async (req, res) => {
  const { imageId, account } = req.body;

  const imageUrl = imageMap.get(imageId);
  if (!imageUrl) {
    return res.status(400).json({ error: 'Invalid image ID' });
  }

  try {
    // Upload the image to IPFS
    const imageResponse = await axios.get(imageUrl, { responseType: 'arraybuffer' });
    const imageBuffer = Buffer.from(imageResponse.data);
    const imageResult = await ipfsClient.add(imageBuffer);

    const imageCID = imageResult.path;
    const ipfsImageUrl = `https://ipfs.io/ipfs/${imageCID}`;

    // Create the metadata object for the NFT
    const metadata = {
      name: 'AI Generated Image',
      description: 'An image generated by AI',
      image: ipfsImageUrl,
    };

    const metadataBuffer = Buffer.from(JSON.stringify(metadata));
    const metadataResult = await ipfsClient.add(metadataBuffer);

    const metadataCID = metadataResult.path;
    const ipfsMetadataUrl = `https://ipfs.io/ipfs/${metadataCID}`;

    // Load the ABI
    const AIGeneratedNFT_ABI = await loadABI('./AIGeneratedNFT_ABI.json');
    console.log('Loaded ABI');

    // Create the contract instance
    const contractInstance = new web3.eth.Contract(AIGeneratedNFT_ABI.abi, CONTRACT_ADDRESS);
    console.log('Created contract instance');

    const nonce = await contractInstance.methods.getNonce(account).call();
    console.log('Got nonce', nonce);

    const PRIVATE_KEY = process.env.BACKEND_PRIVATE_KEY;

    // Create the message hash
    const messageHash = web3.utils.soliditySha3(
      account, ipfsMetadataUrl, nonce, CONTRACT_ADDRESS
    );
  
    console.log('messageHash:', messageHash);
  
    // Sign the message hash with the backend's private key
    const signature = web3.eth.accounts.sign(messageHash, PRIVATE_KEY);
    
    // Return the metadata, nonce, and signature to the frontend for tx submission
    res.json({
      metadataUrl: ipfsMetadataUrl,
      nonce: nonce,
      signature: signature.signature 
    });
    
  } catch (error) {
    console.error('Error minting NFT:', error);
    res.status(500).json({ error: 'Error minting NFT' });
    }
    });
    
    const PORT = process.env.PORT || 3001;
    app.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}`);
    });